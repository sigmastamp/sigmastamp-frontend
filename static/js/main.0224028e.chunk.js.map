{"version":3,"sources":["components/Loader.tsx","components/AsyncContentComponent.tsx","components/ObservableContentComponent.tsx","components/QRCode.tsx","components/PaymentGate.tsx","components/PdfPage.tsx","components/UploadZone.tsx","utils/readFile.tsx","utils/getAsByteArray.tsx","utils/uint8ArrayToHex.tsx","hash/blake2b256.ts","oracles/_AbstractBlockcyptherOracle.ts","oracles/BitcoinOracle.ts","oracles/DateOracle.ts","oracles/EthereumOracle.ts","oracles/LitecoinOracle.ts","oracles/NytimesOracle.ts","smartcontracts/addressValidator.ts","config.ts","smartcontracts/compileErgoScript.ts","smartcontracts/createScript.ts","smartcontracts/getCurrentBlockchainInfo.ts","smartcontracts/ergoFormat/hex/hexToErgoFormat.ts","smartcontracts/ergoFormat/url/urlToErgoFormat.ts","utils/convertToHex.ts","smartcontracts/sendFollowRequest.ts","smartcontracts/createSigmaStampNFT.ts","App.tsx","utils/hexToBase64.ts","smartcontracts/validateFirstCertificate.ts","VerifyApp.tsx","index.tsx"],"names":["Loader","LoaderDiv","className","styled","div","AsyncContentComponent","loading","content","React","state","setState","a","factorable","ObservableContentComponent","loader","subscription","subscribe","newContentAwaitable","newContent","unsubscribe","QRCode","props","href","link","target","rel","ref","canvasElement","options","color","QRCodeGenerator","toCanvas","error","console","PaymentGate","amount","address","dueDate","paymentStatus","URL","PaymentGateDiv","pipe","map","checkedDate","isPayed","date","overtime","renderer","minutes","seconds","toUTCString","catchError","of","message","PdfPage","pageRef","useRef","createUi","createPdf","doc","jsPDF","text","current","innerText","output","PdfPageDiv","children","UploadZone","uploadClick","this","onFile","onFiles","onFileOver","onFilesOver","clickable","onFileOverMaybe","isFileOver","UploadZoneDiv","onClick","onDragEnter","event","stopPropagation","preventDefault","onDragOver","onDragExit","onDragEnd","onDrop","files","Array","from","dataTransfer","type","element","click","onChange","readFile","file","Promise","resolve","reject","reader","FileReader","addEventListener","result","readAsArrayBuffer","getAsByteArray","Uint8Array","uint8ArrayToHex","uint8Array","x","toString","padStart","join","blake2b256","input","context","blake2bInit","undefined","blake2bUpdate","hashUint8Array","blake2bFinal","hash","AbstractBlockcyptherOracle","name","title","dataTitles","ttl","fetch","toLowerCase","response","json","body","Error","BitcoinOracle","DateOracle","time","Date","getUTCFullYear","getUTCMonth","slice","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","EthereumOracle","LitecoinOracle","NytimesOracle","firstTitle","rssParser","RssParser","parseURL","feed","items","isUserAddressValid","userAddress","Address","isValid","VERSION","version","config","ConfigChecker","process","ERGO_ASSEMBLER_URL","get","url","required","value","BUILD_DETAILS_URL","BUILD_DATE","compileErgoScript","script","JSON","stringify","trim","split","method","headers","catch","compilerResponse","compilerResponseBody","success","detail","createScript","Object","entries","filter","key","scriptArray","length","match","param","substring","getCurrentBlockchainHeight","height","hexToErgoFormat","hex","urlToErgoFormat","str","i","charCodeAt","convertToHex","sendFollowRequest","compiledSmartContractAddress","sigmaStampProviderAddress","documentHashInHex","ergsSendTogetherWithNFT","ergsFeeForSigmaStampService","mintingFee","requestBody","returnTo","startWhen","erg","txSpec","requests","ergValue","decimals","description","registers","R7","R8","R9","fee","inputs","dataInputs","followResponse","followResponseBody","transactionId","id","dueTime","getTime","BehaviorSubject","forTimeSynced","complete","watchResponse","watchResponseBody","tx","log","next","createSigmaStampNFT","documentHashInBase64","assetTypeValue","returnTransactionFee","sigmaStampAssemblerNodeAddr","refundHeightThreshold","ORACLES","App","useState","payment","setPayment","AppDiv","File","certificateFile","zip","JSZip","generateAsync","zipBlob","zipHash","btoa","String","fromCharCode","apply","replace","zipHashBase64","saveAs","prompt","oracle","getData","data","to","validateFirstCertificate","firstCertificate","tokensResponse","tokensBody","item","emissionAmount","boxId","boxesResponse","boxesBody","additionalRegisters","renderedValue","getTransactionTime","txId","timestamp","tokenId","outputs","assets","getNFTHolderAddress","total","VerifyApp","setFiles","verification","setVerification","currentHolder","VerifyAppDiv","droppedFiles","droppedFileVerification","alert","info","toISOString","HeaderElement","header","ReactDOM","render","StrictMode","alt","src","path","document","getElementById"],"mappings":"qeAGO,SAASA,IACZ,OACI,cAACC,EAAD,UAII,qBAAKC,UAAU,cAK3B,IAAMD,EAAYE,IAAOC,IAAV,0BCyBR,SAASC,EAAT,GAG0B,IAF7BC,EAE4B,EAF5BA,QACAC,EAC4B,EAD5BA,QAEA,EAA0BC,WAA4C,CAClED,QAASD,GAAW,cAACN,EAAD,MADxB,mBAAOS,EAAP,KAAcC,EAAd,KAcA,OAVAF,aAAgB,WAKZ,OAJA,sBAAC,sBAAAG,EAAA,kEACGD,EADH,SAvCqB,oBADJE,EAyCmBL,GAvC7BK,IAEDA,EAoCN,yBACcL,QADd,sDAxCF,IAAmBK,IAwCjB,MAAD,GAIO,eAGR,CAACL,IAEG,mCAAGE,EAAMF,U,wCC1Bb,SAASM,EAAT,GAG+B,IAFlCC,EAEiC,EAFjCA,OACAP,EACiC,EADjCA,QAEA,EAA0BC,WAAiD,CACvED,QAASO,GAAU,cAACd,EAAD,MADvB,mBAAOS,EAAP,KAAcC,EAAd,KAaA,OATAF,aAAgB,WACZ,IAAMO,EAAeR,EAAQS,UAAR,uCAAkB,WAAOC,GAAP,eAAAN,EAAA,sEACVM,EADU,OAC7BC,EAD6B,OAEnCR,EAAS,CAAEH,QAASW,IAFe,2CAAlB,uDAKrB,OAAO,kBAAMH,EAAaI,iBAC3B,CAACZ,IAEG,mCAAGE,EAAMF,U,wBCzCb,SAASa,EAAOC,GACnB,IAAMC,EAAOD,EAAME,KAAKD,KAExB,OACI,mBAASA,OAAQE,OAAO,SAASC,IAAI,sBAArC,SACI,wBACIC,IAAK,SAACC,GACF,GAAKA,EAAL,CAKA,IAAMC,EAA+B,eAAQP,UACrCO,EAAgBN,KACxBM,EAAQC,MAAQD,EAAQC,OAAS,GAEjCC,IAAgBC,SACZJ,EACAL,EACAM,GACA,SAACI,GACOA,GACAC,QAAQD,MAAMA,YCZvC,SAASE,EAAT,GAKgB,IAJnBC,EAIkB,EAJlBA,OACAC,EAGkB,EAHlBA,QACAC,EAEkB,EAFlBA,QACAC,EACkB,EADlBA,cAIMf,EAAO,IAAIgB,IAAJ,oEACoDH,EADpD,mBAELD,EAAS,MAIjB,OACI,cAACK,EAAD,UACI,cAAC3B,EAAD,CACIN,QAAS+B,EACJG,KACGC,aAAI,gBAAGC,EAAH,EAAGA,YAAH,SAAgBC,QAqCZ,0DAnCA,qCACI,cAACxB,EAAD,CAAcG,SADlB,OAESY,EAAS,IAFlB,kBAE6C,IACzC,mBACIb,KAAMC,EAAKD,KACXE,OAAO,SACPC,IAAI,sBAHR,SAKKW,IAEL,uBAVJ,KAWO,IACH,cAAC,IAAD,CACIS,KAAMR,EACNS,UAAU,EACVC,SAAU,gBAAGC,EAAH,EAAGA,QAASC,EAAZ,EAAYA,QAAZ,OACN,qCACKD,EADL,IACeC,QAIvB,uBArBJ,QAsBU,IAEFZ,EAAQa,cAEZ,uBACA,cAAClD,EAAD,IA3BJ,uBA4BI,uBA5BJ,kBA6BoB,IAEZ2C,EAAYO,qBAW/BT,KACGU,aAAW,SAACnB,GAAD,OAAkBoB,YAAG,mCAAGpB,EAAMqB,mBAOjE,I,EAAMb,EAAiBrC,IAAOC,IAAV,qE,SC5Eb,SAASkD,EAAQjC,GACpB,IAAMkC,EAAUC,iBAAO,MAEvB,OACI,gCACKnC,EAAMoC,SAAS,CACZC,UAAU,WAAD,4BAAE,4BAAA/C,EAAA,6DACDgD,EAAM,IAAIC,KAeZC,KAAMN,EAASO,QAAgBC,UAAW,GAAI,IAhB3C,kBAkBAJ,EAAIK,OAAO,SAlBX,2CAAF,kDAAC,KAqBd,cAACC,EAAD,CAAYvC,IAAK6B,EAAjB,SAA2BlC,EAAM6C,cAK7C,I,EAAMD,EAAa9D,IAAOC,IAAV,qJACH,IACC,K,gCCnCD+D,EAAb,4JACI,WACI,IAYIC,EAZJ,EAKIC,KAAKhD,MAJL6C,EADJ,EACIA,SACSI,EAFb,EAEIC,QACaC,EAHjB,EAGIC,YACAC,EAJJ,EAIIA,UAEEC,EAAkB,SAACC,GACjBJ,GACAA,EAAWI,IAMnB,OACI,eAACC,EAAD,CACIC,QAAS,WACDJ,GACAN,KAGRW,YAAa,SAACC,GACVA,EAAMC,kBACND,EAAME,kBAEVC,WAAY,SAACH,GACTA,EAAMC,kBACND,EAAME,iBACNP,GAAgB,IAEpBS,WAAY,SAACJ,GACTA,EAAMC,kBACND,EAAME,iBACNP,GAAgB,IAEpBU,UAAW,SAACL,GACRA,EAAMC,kBACND,EAAME,kBAEVI,OAAQ,SAACN,GACLA,EAAME,iBACNF,EAAMC,kBACNN,GAAgB,GAEhB,IAAMY,EAAQC,MAAMC,KAAKT,EAAMU,aAAaH,OAC5CjB,EAAOiB,IA9Bf,UAiCI,uBACII,KAAK,OACLjE,IAAK,SAACkE,GACEA,IACAxB,EAAc,WACVO,GAAgB,GACfiB,EAA6BC,WAI1CC,SAAU,SAACd,GACFA,GAAUA,EAAMxD,QAAWwD,EAAMxD,OAAO+D,OAE7CjB,EAAOkB,MAAMC,KAAKT,EAAMxD,OAAO+D,WAItCrB,SAnEjB,GAAgC1D,aAyE1BqE,EAAgB1E,IAAOC,IAAV,qKACN,IACC,K,QCtFP,SAAS2F,EAASC,GACrB,OAAO,IAAIC,SAAQ,SAACC,EAASC,GACzB,IAAMC,EAAS,IAAIC,WAEnBD,EAAOE,iBAAiB,WAAW,SAACtB,GAAD,OAC/BkB,EAAQlB,EAAMxD,OAAQ+E,WAE1BH,EAAOE,iBAAiB,QAASH,GAEjCC,EAAOI,kBAAkBR,MCP1B,SAAeS,EAAtB,kC,4CAAO,WAA8BT,GAA9B,SAAArF,EAAA,kEACQ+F,WADR,SACyBX,EAASC,GADlC,wG,mCCFA,SAASW,EAAgBC,GAC5B,OAAO,YAAIA,GAAYlE,KAAI,SAACmE,GAAD,OAAOA,EAAEC,SAAS,IAAIC,SAAS,EAAG,QAAMC,KAAK,ICIrE,SAAeC,EAAtB,mC,8CAAO,WAA0BC,GAA1B,mBAAAvG,EAAA,6DACS,KACU,GAChBwG,EAAUC,sBADM,QAC4BC,GAH/C,KAMHC,gBANG,KAMWH,EANX,SAM0BV,EAAeS,GANzC,8CASGK,EAAiBC,uBAAaL,GAG9BM,EAAOd,EAAgBY,GAZ1B,kBAcIE,GAdJ,6C,sBCHA,IAAeC,GAAtB,iDAGoBC,UAHpB,OAIoBC,WAJpB,OAMWC,WAAa,CAAEJ,KAAM,sBANhC,KAOWK,KAAO,EAPlB,kFASI,wGAC2BC,MAAM,kCAAD,OACU1D,KAAKsD,KAAKK,cADpB,UADhC,cACUC,EADV,gBAMuBA,EAASC,OANhC,YAMUC,EANV,QAQanG,MARb,sBASc,IAAIoG,MAAMD,EAAKnG,OAT7B,cAYYyF,EAASU,EAATV,KAZZ,kBAaW,CAAEA,SAbb,iDATJ,6DCAaY,GAAb,4MACWV,KAAO,MADlB,EAEWC,MAAQ,UAFnB,YAAmCF,ICAtBY,GAAb,iDACWX,KAAO,OADlB,KAEWC,MAAQ,UAFnB,KAGWE,IAAM,EAHjB,KAKWD,WAAa,CAAEhF,KAAM,OAAQ0F,KAAM,QAL9C,2CAOI,WACI,IAAM1F,EAAO,IAAI2F,KACjB,MAAO,CACH3F,KAAK,GAAD,OAAKA,EAAK4F,iBAAV,aAA+B,IAAM5F,EAAK6F,eAAeC,OACxD,GADD,aAEE,IAAM9F,EAAK+F,cAAcD,OAAO,IACtCJ,KAAK,GAAD,QAAM,IAAM1F,EAAKgG,eAAeF,OAAO,GAAvC,aACA,IAAM9F,EAAKiG,iBACbH,OAAO,GAFL,aAEY,IAAM9F,EAAKkG,iBAAiBJ,OAAO,SAf/D,KCAaK,GAAb,4MACWrB,KAAO,MADlB,EAEWC,MAAQ,WAFnB,YAAoCF,ICAvBuB,GAAb,4MACWtB,KAAO,MADlB,EAEWC,MAAQ,WAFnB,YAAoCF,I,qBCCvBwB,GAAb,iDACWvB,KAAO,UADlB,KAEWC,MAAQ,qBAFnB,KAGWE,KAAO,EAHlB,KAKWD,WAAa,CAAEsB,WAAY,eALtC,kFAOI,6FACUC,EAAY,IAAIC,KAD1B,SAEuBD,EAAUE,SAAV,0DAFvB,cAEUC,EAFV,yBAQW,CACHJ,WAAYI,EAAKC,MAAM,GAAG5B,QATlC,2CAPJ,6D,UCAO,SAAe6B,GAAtB,mC,8CAAO,WACHC,GADG,SAAA/I,EAAA,wFAIS,IAAIgJ,WAAQD,GAAaE,WAJlC,0DAMQ,GANR,yD,oCCEMC,G,OAAUC,EAEjBC,GAASC,iBAAcvE,KAAKwE,kWAMrBC,GAAqBH,GAC7BI,IACG,gCAEHC,MAIAC,WAAWC,MAEHC,GAAoBR,GAC5BI,IACG,+BAEHC,MAAME,MAKEE,GAAaT,GACrBI,IACG,wBAEHtH,OAAOyH,MC1BL,SAAeG,GAAtB,mC,8CAAO,qCAAA9J,EAAA,6DACH+J,EADG,EACHA,OAIMvC,EAAOwC,KAAKC,UAAUF,EAAOG,QAE9BC,MAAM,OACN9D,KAAK,MACL8D,MAAM,QACN9D,KAAK,MAEJoD,EAZH,UAYYF,GAAmB5I,KAZ/B,oBAa4ByG,MAAMqC,EAAK,CACtCW,OAAQ,OACR5C,OACA6C,QAAS,CACL,eAAgB,sBAErBC,OAAM,WACL,MAAM,IAAI7C,MAAJ,8CAAiDgC,EAAjD,UApBP,cAaGc,EAbH,gBAuBgCA,EAAiBhD,OAvBjD,WAyBkC,KAF/BiD,EAvBH,QAyBsBC,QAzBtB,uBA0BO,IAAIhD,MAAJ,0CACiC+C,EAAqBE,SA3B7D,iCA+BIF,GA/BJ,6C,sBCRA,SAAeG,GAAtB,mC,8CAAO,WACH1J,GADG,+BAAAjB,EAAA,sEAGoBoH,MAAMnG,EAAQ8I,QAHlC,cAGGzC,EAHH,gBAIgBA,EAASpE,OAJzB,OAIC6G,EAJD,qBAQwBa,OAAOC,QAAQ5J,GAAS6J,QAE/C,kBAAmB,WAAnB,wBAVD,qFAQSC,EART,KAQcpB,EARd,KAa4B,KADrBqB,EAAcjB,EAAOI,MAAP,WAAiBY,KACrBE,OAbjB,uBAcW,IAAIxD,MAAJ,gCACuBsD,EADvB,4BAC8C9J,EAAQ8I,OADtD,MAdX,QAkBCA,EAASiB,EAAY3E,KAAKsD,GAlB3B,oJAuBGuB,EAAQnB,EAAOmB,MAAM,oBAvBxB,uBAyBO,IAAIzD,MAAJ,yBACgByD,EACbnJ,KAAI,SAACoJ,GAAD,iBAAeA,EAAMC,UAAU,GAA/B,QACJ/E,KAAK,MAHR,4BAGiCpF,EAAQ8I,OAHzC,OAzBP,iCAgCI,CAAEA,WAhCN,iE,sBCFA,SAAesB,KAAtB,gC,8CAAO,8BAAArL,EAAA,sEAEoBoH,MAAM,oDAF1B,cAEGE,EAFH,gBAMgBA,EAASC,OANzB,cAMGC,EANH,yBAQIA,EAAK8D,QART,4C,iDCOA,SAASC,GAAgBC,GAE5B,MAAM,OAAN,OAAcA,GCDX,SAASC,GAAgBhC,GAC5B,MAAM,KAAN,OAAYA,EAAIwB,OAAO9E,SAAS,KAAhC,OCPG,SAAsBuF,GAEzB,IADA,IAAIF,EAAM,GACDG,EAAI,EAAGA,EAAID,EAAIT,OAAQU,IAC5BH,GAAO,GAAKE,EAAIE,WAAWD,GAAGxF,SAAS,IAE3C,OAAOqF,EDE+BK,CAAapC,IEOhD,SAAeqC,GAAtB,mC,8CAAO,yDAAA9L,EAAA,6DACH+L,EADG,EACHA,6BACAhD,EAFG,EAEHA,YACAiD,EAHG,EAGHA,0BACAC,EAJG,EAIHA,kBACAC,EALG,EAKHA,wBACAC,EANG,EAMHA,4BACAC,EAPG,EAOHA,WAyBMC,EAAc,CAChB5K,QAASsK,EACTO,SAAUvD,EACVwD,UAAW,CAAEC,IANXhL,EACF0K,EAA0BC,EAA8BC,GAMxDK,OAAQ,CACJC,SAAU,CACN,CACIC,SAAUT,EACVzK,QAASsH,EACT/B,KAAM,gBACNxF,OAAQ,EACRoL,SAAU,EACVC,YACI,kHACJC,UAAW,CACPC,GAAI,WACJC,GAAIzB,GAAgBU,GACpBgB,GAAIxB,GAAe,6CAGuBQ,MAIlD,CACItC,MAAOwC,EACP1K,QAASuK,IAGjBkB,IAAKd,EACLe,OAAQ,CAAC,YACTC,WAAY,KA/DjB,SAmE0BhG,MAAM,GAAD,OAAImC,GAAmB5I,KAAvB,UAAqC,CACnEyJ,OAAQ,OACRC,QAAS,CACL,eAAgB,oBAEpB7C,KAAMwC,KAAKC,UAAUoC,KAxEtB,cAmEGgB,EAnEH,gBA2E8BA,EAAe9F,OA3E7C,cA2EG+F,EA3EH,OA4ESC,EAA2BD,EAA/BE,GAAmBC,EAAYH,EAAZG,QAErB/L,EAAU,IAAImG,MAAK,IAAIA,MAAO6F,UAAsB,IAAVD,GAG1C9L,EAAgB,IAAIgM,KAAgB,CACtC3L,YACI,IAAI6F,KACR5F,SAAS,IAGb,sBAAC,kCAAAjC,EAAA,sEAGa4N,yBAAc,KAH3B,aAMW,IAAI/F,MAA2E6F,UAC/EhM,EAAQgM,WAPnB,uBASW/L,EAAcN,MACV,IAAIoG,MACA,YAGR9F,EAAckM,WAdzB,0CAmBmCzG,MAAM,GAAD,OAC1BmC,GAAmB5I,KADO,kBACO4M,IApB/C,cAmBaO,EAnBb,iBAsBuCA,EAAcvG,OAtBrD,WAsBawG,EAtBb,OAwBmBC,EAERD,EAFQC,GACRtD,EACAqD,EADArD,OAGJpJ,QAAQ2M,IAAI,CAAEH,gBAAeC,oBAAmBC,KAAItD,WAErC,YAAXA,EA9BX,wBAiCW/I,EAAcuM,KAAK,CACflM,YACI,IAAI6F,KACR5F,SAAS,IAEbN,EAAckM,WAtCzB,2BA0COlM,EAAcuM,KAAK,CACflM,YACI,IAAI6F,KACR5F,SAAS,IA7CpB,0DAAD,GAvFG,kBAyII,CACHT,SACAE,UACAC,kBA5ID,6C,sBCEA,SAAewM,GAAtB,mC,8CAAO,iEAAAnO,EAAA,6DACH+I,EADG,EACHA,YACAqF,EAFG,EAEHA,qBACAnC,EAHG,EAGHA,kBAHG,SAUSnD,GAAmBC,GAV5B,uCAWO,IAAItB,MAAJ,wBAA2BsB,EAA3B,sBAXP,cA4BGqD,EAAa,IACbF,EAA0B,IAC1BC,EAA8B,IAE9BH,EACF,uDACEqC,EAAiB,OAEjBC,EAAuB,IAMvBC,EACF,uDA3CD,UA6CkClD,KA7ClC,2BA6CGmD,EA7CH,KA6CkE,GAErElN,QAAQ2M,IACJjE,KAAKC,UAAU,CACXiC,0BACAnD,cACAoD,8BACAH,4BACAqC,iBACAD,uBACAE,uBACAC,8BACAC,2BAzDL,UA6DsB7D,GAAa,CAClCZ,OAAQ,gCAGRmC,0BACAnD,cACAoD,8BACAH,4BACAqC,iBACAD,uBACAE,uBACAC,8BACAC,0BAzED,wBA6DKzE,EA7DL,EA6DKA,OA7DL,UA4EqDD,GAAkB,CACtEC,WA7ED,wBA4EcgC,EA5Ed,EA4EKtK,QA5EL,UAgF8CqK,GAAkB,CAC/DC,+BACAhD,cACAiD,4BACAC,oBACAC,0BACAC,8BACAC,eAvFD,wBAgFK5K,EAhFL,EAgFKA,OAAQE,EAhFb,EAgFaA,QAASC,EAhFtB,EAgFsBA,cAhFtB,kBA0FI,CACHH,SACAC,QAASsK,EACTrK,UACAC,kBA9FD,6C,sBCCP,IAAM8M,GAAU,CACZ,IAAI/G,GACJ,IAAIW,GACJ,IAAIC,GACJ,IAAIX,GACJ,IAAIY,IAOD,SAASmG,KACZ,MAA0BC,mBAAoB,CAAE/J,MAAO,KAAvD,mBAAO9E,EAAP,KAAcC,EAAd,KACA,EAA8B4O,mBAAmC,MAAjE,mBAAOC,EAAP,KAAgBC,EAAhB,KAEA,OAAKD,EA6KM,cAACrN,EAAD,eAAiBqN,IA3KpB,eAACE,GAAD,WAS4B,IAAvBhP,EAAM8E,MAAMqG,OACT,cAAC,EAAD,CACIrH,QAAO,uCAAE,WAAOgB,GAAP,SAAA5E,EAAA,sDACLD,EAAS,CAAE6E,UADN,2CAAF,sDAmBPb,WAAS,EApBb,uCAyBA,eAACpB,EAAD,CACIG,SAAU,YAAoB,IAAjBC,EAAgB,EAAhBA,UACT,OACI,wBACIoB,QAAO,sBAAE,4CAAAnE,EAAA,kEACuB+O,KADvB,SAEMhM,IAFN,+BACCiM,EADD,cAGD,oBAKEC,EAAM,IAAIC,IARX,cAScpP,EAAM8E,OATpB,IASL,2BAAWS,EAAqB,QAC5B4J,EAAI5J,KAAKA,EAAK2B,KAAM3B,GAVnB,qCAYL4J,EAAI5J,KACA2J,EAAgBhI,KAChBgI,GAdC,UAiBiBC,EAAIE,cACtB,CAAEnK,KAAM,SAlBP,eAiBCoK,EAjBD,iBAsBK9I,EAAW8I,GAtBhB,eAqBCC,EArBD,iBC1EjB3D,EDmGkC2D,EClGnDC,KACHC,OAAOC,aAAaC,MAChB,KAEA/D,EACKgE,QAAQ,SAAU,IAClBA,QAAQ,qBAAsB,SAC9BA,QAAQ,MAAO,IACfvF,MAAM,ODiEsB,WAwBCwF,EAxBD,OA2BLC,iBACIR,EADE,uBAEcC,EAAQjE,UACpB,EACA,GAJF,SAYArC,EAAc8G,OAChB,gCACA,wDAzCC,+DAiDLhB,EAjDK,UAkDKV,GAAoB,CACtBpF,cACAqF,qBACIuB,EACJ1D,kBAAmBoD,IAtDtB,qEC1EtC,IAAqB3D,ID0EiB,OADb,uCAHZ,UAoEK5L,EAAM8E,MAAM7C,KAAI,SAACsD,GAAD,OACb,cAAC3F,EAAD,CAEIE,QAAO,sBAAE,4BAAAI,EAAA,sEACcsG,EAAWjB,GADzB,cACCyB,EADD,yBAGD,qCACI,yCAAYzB,EAAK2B,QADrB,OACmCF,MAJlC,4CADJzB,EAAK2B,SAYjByH,GAAQ1M,KAAI,SAAC+N,GAAD,OACT,8BACI,cAACpQ,EAAD,CACIE,QAAO,sBAAE,4BAAAI,EAAA,sEACc8P,EAAOC,UADrB,cACCC,EADD,yBAID,mCACKpF,OAAOC,QAAQmF,GAAMjO,KAClB,mCAAEgJ,EAAF,KAAOpB,EAAP,YACI,gCACI,8BAEKmG,EAAO7I,MAGA6I,EAEC5I,WACD6D,GARZ,OAaCpB,IAdKoB,SAPrB,8CAFP+E,EAAO9I,YAoC7B,+BACI,6BACI,cAAC,IAAD,CAAMiJ,GAAG,UAAUpP,OAAQ,SAA3B,+CAIJ,6BACI,cAAC,IAAD,CAAMoP,GAAG,SAAT,oIAcxB,I,GAAMnB,GAAStP,IAAOC,IAAV,+F,OEjNL,SAAeyQ,GAAtB,mC,8CAAO,WAAwCC,GAAxC,+BAAAnQ,EAAA,sEAEgBsG,EAAW6J,GAF3B,cAEGrJ,EAFH,gBAI0BM,MAAM,iFAJhC,cAIGgJ,EAJH,gBAOsBA,EAAe7I,OAPrC,OAOG8I,EAPH,qBASeA,EAAWxH,OAT1B,8DAY4B,KAHrByH,EATP,SAYSC,eAZT,+DAcOC,EAAQF,EAAKE,MAdpB,UAgB6BpJ,MAAM,qDAAD,OACwBoJ,IAjB1D,eAgBOC,EAhBP,iBAoByBA,EAAclJ,OApBvC,WAyBI,UALGmJ,EApBP,QAyBcC,oBAAoB5D,GAAG6D,cAzBrC,2DA2BIF,EAAUC,oBAAoB3D,GAAG4D,gBAAjC,UAAsD9J,GA3B1D,0CA4BY4J,GA5BZ,0KAgCI,MAhCJ,kE,sBAuCA,SAAeG,GAAtB,mC,8CAAO,WAAkCC,GAAlC,qBAAA9Q,EAAA,sEAEoBoH,MAAM,4DAAD,OACoC0J,IAH7D,cAEGxJ,EAFH,gBAKgBA,EAASC,OALzB,cAKGC,EALH,OAOHlG,QAAQ2M,IAAI,qBAAsBzG,GAE5BuJ,EAAYvJ,EAAKuJ,UACjBC,EAAUxJ,EAAKyJ,QAAQ,GAAGC,OAAO,GAAGF,QAVvC,kBAYI,CAAED,YAAWC,YAZjB,6C,sBAeA,SAAeG,GAAtB,mC,8CAAO,WAAmCH,GAAnC,iBAAAhR,EAAA,sEAEoBoH,MAAM,uEAAD,OAC+C4J,IAHxE,cAEG1J,EAFH,gBAKgBA,EAASC,OALzB,UAKGC,EALH,OAOHlG,QAAQ2M,IAAI,sBAAuBzG,GAGjB,IAAfA,EAAK4J,MAVL,yCAUyB,MAVzB,gCAYI5J,EAAKqB,MAAM,GAAGpH,SAZlB,6C,sBC3CA,SAAS4P,KACZ,MAA0B1C,mBAAc,IAAxC,mBAAO/J,EAAP,KAAc0M,EAAd,KACA,EAAwC3C,mBAAc,MAAtD,mBAAO4C,EAAP,KAAqBC,EAArB,KAEA,OAAKD,EAmDG,eAAC5O,EAAD,CACIG,SAAU,YAAoB,IAAjBC,EAAgB,EAAhBA,UACT,OACI,wBACIoB,QAAO,sBAAE,wCAAAnE,EAAA,kEACuB+O,KADvB,SAEMhM,IAFN,+BACCiM,EADD,cAGD,oBASEC,EAAM,IAAIC,IAZX,cAactK,GAbd,IAaL,2BAAWS,EAAe,QACtB4J,EAAI5J,KAAKA,EAAK2B,KAAM3B,GAdnB,qCAgBL4J,EAAI5J,KAAK2J,EAAgBhI,KAAMgI,GAhB1B,UAkBiBC,EAAIE,cAAc,CACpCnK,KAAM,SAnBL,eAkBCoK,EAlBD,iBAsBiB9I,EAAW8I,GAtB5B,QAsBCC,EAtBD,OAuBLO,iBACIR,EADE,uBAEcC,EAAQjE,UACpB,EACA,GAJF,SAvBD,4CADb,uCAHZ,UAyCI,+CAzCJ,IAyC2BmG,EAAahE,cACpC,uBACA,2CA3CJ,IA2CuBgE,EAAaR,UAChC,uBACA,yCA7CJ,IA6CqBQ,EAAaP,QAC9B,uBACA,gDA/CJ,IA+C4BO,EAAaE,iBAhGzC,eAACC,GAAD,WACI,cAAC,EAAD,CACI9N,QAAO,uCAAE,WAAO+N,GAAP,2BAAA3R,EAAA,6DACCmQ,EAAmBwB,EAAa,GACtCL,EAAS,CAACK,EAAa,KAFlB,SAIiCzB,GAClCC,GALC,cAICyB,EAJD,SASDC,MAAM,wEAQFtE,EAAkBqE,EAAlBrE,cAjBH,SAmBgCsD,GACjCtD,GApBC,uBAmBGwD,EAnBH,EAmBGA,UAAWC,EAnBd,EAmBcA,QAnBd,UA0BuBG,GAAoBH,GA1B3C,QA0BCS,EA1BD,OA4BLD,EAAgB,2BACTI,GADQ,IAEXb,YACAC,UACAS,mBAEJnQ,QAAQ2M,IAAI2D,GAlCP,4CAAF,sDAoCP7N,WAAS,EArCb,0CAyCA,cAAC,IAAD,CAAMkM,GAAG,IAAIpP,OAAQ,SAArB,gDA4DhB,I,GAAM6Q,GAAelS,IAAOC,IAAV,+FCjHlB6B,QAAQwQ,KACJ,4CAA2B5I,KACrBW,GAAD,oBAAgCA,GAAWkI,eAA3C,KACCnI,GAAD,8BAE4BA,GAAkBjJ,MAF9C,IAHT,6GASA,IAAMqR,GAAgBxS,IAAOyS,OAAV,wEAMnBC,IAASC,OACL,eAAC,IAAMC,WAAP,WACI,cAACJ,GAAD,UACI,sBAAKxE,GAAG,yBAAR,UACI,qBACIjO,UAAU,WACV8S,IAAI,kBACJC,IAAI,wBAER,iDAIR,cAAC,IAAD,UACI,eAAC,IAAD,WACI,cAAC,IAAD,CAAOC,KAAK,IAAItN,QAAS,cAACyJ,GAAD,MACzB,cAAC,IAAD,CAAO6D,KAAK,UAAUtN,QAAS,cAACoM,GAAD,cAI3CmB,SAASC,eAAe,W","file":"static/js/main.0224028e.chunk.js","sourcesContent":["import * as React from 'react';\nimport styled from 'styled-components';\n\nexport function Loader() {\n    return (\n        <LoaderDiv>\n            {/* TODO: Please @roseckyj  loader that would cover only its area not the whole modal, */}\n            {/* TODO: Please @roseckyj make it universal to use it in every layout type - small icon, fullscreen, modal, etc,... */}\n            {/* TODO: Please @roseckyj untite with LoaderInline */}\n            <div className=\"spinner\"></div>\n        </LoaderDiv>\n    );\n}\n\nconst LoaderDiv = styled.div``;\n","import * as React from 'react';\nimport { Promisable } from 'type-fest';\nimport { Loader } from './Loader';\n\nexport type IFactory<T> = () => T;\n\nexport type IFactorable<T> = T | IFactory<T>;\n\nexport function factor<T>(factorable: IFactorable<T>): T {\n    if (typeof factorable === 'function') {\n        return (factorable as any)();\n    } else {\n        return factorable;\n    }\n}\n\ninterface IAsyncContentComponentProps {\n    /**\n     * Component to be rendered before the content is loaded\n     *\n     * If not set, default loading is used\n     */\n    loading?: JSX.Element;\n\n    /**\n     * The async content to be rendered\n     */\n    content: IFactorable<Promisable<JSX.Element>>;\n}\n\ninterface IAsyncContentComponentState {\n    content: JSX.Element;\n}\n\n/**\n * Utility for mounting RxJS observable content\n *\n * @collboard-modules-sdk\n */\nexport function AsyncContentComponent({\n    loading,\n    content,\n}: IAsyncContentComponentProps) {\n    const [state, setState] = React.useState<IAsyncContentComponentState>({\n        content: loading || <Loader />,\n    });\n\n    React.useEffect(() => {\n        (async () => {\n            setState({ content: await factor(content) });\n        })();\n\n        return () => {\n            /* TODO: Can here be some reasonable teardown logic? */\n        };\n    }, [content]);\n\n    return <>{state.content}</>;\n}\n","import * as React from 'react';\nimport { Observable } from 'rxjs';\nimport { Promisable } from 'type-fest';\nimport { Loader } from './Loader';\n/**\n * TODO: Make from this some microlibrary\n */\n\ninterface IObservableContentComponentProps {\n    /**\n     * Component to be rendered before the content is loaded\n     *\n     * If not set, default <Loader/> is used\n     */\n    loader?: JSX.Element;\n\n    /**\n     * You can put here any RxJS observable. For example BehaviorSubject.\n     */\n    content: Observable<Promisable<JSX.Element>>;\n}\n\ninterface IObservableContentComponentState {\n    content: JSX.Element;\n}\n\n/**\n * Utility for mounting RxJS observable content\n *\n * @collboard-modules-sdk\n */\nexport function ObservableContentComponent({\n    loader,\n    content,\n}: IObservableContentComponentProps) {\n    const [state, setState] = React.useState<IObservableContentComponentState>({\n        content: loader || <Loader />,\n    });\n\n    React.useEffect(() => {\n        const subscription = content.subscribe(async (newContentAwaitable) => {\n            const newContent = await newContentAwaitable;\n            setState({ content: newContent });\n        });\n\n        return () => subscription.unsubscribe();\n    }, [content]);\n\n    return <>{state.content}</>;\n}\n","import QRCodeGenerator, { QRCodeRenderersOptions } from 'qrcode';\nimport * as React from 'react';\n\ninterface IQRCodeProps extends QRCodeRenderersOptions {\n    link: URL;\n}\n\nexport function QRCode(props: IQRCodeProps) {\n    const href = props.link.href;\n\n    return (\n        <a {...{ href }} target=\"_blank\" rel=\"noopener noreferrer\">\n            <canvas\n                ref={(canvasElement) => {\n                    if (!canvasElement) {\n                        return;\n                    }\n\n                    // Note: Making some manipulation (probbably) due to internal errors of qrcode library\n                    const options: QRCodeRenderersOptions = { ...props };\n                    delete (options as any).href;\n                    options.color = options.color || {};\n\n                    QRCodeGenerator.toCanvas(\n                        canvasElement,\n                        href,\n                        options,\n                        (error) => {\n                            if (error) {\n                                console.error(error);\n                            }\n                            // console.log('success!');\n                        },\n                    );\n                }}\n            />\n        </a>\n    );\n}\n","import * as React from 'react';\nimport Countdown from 'react-countdown';\nimport { catchError, map, of } from 'rxjs';\nimport styled from 'styled-components';\nimport { IPaymentStatus } from '../interfaces/IPaymentStatus';\nimport { ergo_wallet_address, nanoerg } from '../interfaces/stringTypes';\nimport { Loader } from './Loader';\nimport { ObservableContentComponent } from './ObservableContentComponent';\nimport { QRCode } from './QRCode';\n\nexport interface IPaymentGateProps {\n    amount: nanoerg;\n    address: ergo_wallet_address;\n    dueDate: Date;\n    paymentStatus: IPaymentStatus;\n}\n\nexport function PaymentGate({\n    amount,\n    address,\n    dueDate,\n    paymentStatus,\n}: IPaymentGateProps) {\n    // TODO: !!! Deal up in design in superlong addreses like UegztxGAXchyKXtaZYFkGWxDnCpMD329qSNk4YVrc8wrwitM58WVocMT59rPSasNZJwezshytQ74pq9JF8uUGGYHJW64hbooxY54dDCRZnFVqFvXGcj1jUhkXpuYuVaDY1b6LcXq9zRCZCiXZ36Gswg2TqcgZRE1B5ZxUrKSd19XykEfsgx5eWW3k7MDiLxvisPqMxqpZtP8UHvgwucJxZ4Bg86xWC3v4kXVC6o9mkg7z64MqiQy1FrqHvY65mr7UgG1vK8q37mDcgZPkDc7BKmsKSLynXgDNsqT8yirvxmsCU9o5wMsF8BoFPxUnjPGLAp7yBwnqtvXowq3o4pYnc4h93irPEHqbTySBgLSEwFzgRgbVrXtE8FaL1q2LVyg7rbHJHzvjVfJMyQDSGQwecG6iWybNUv9sP7SKanHegS4wn8xKaBGrSmqTNk4aPpRXvGTr6rikYxmTYDmQru6tJSebRUf7mhsbtp3xTngEgFtPVCMQTnuuNtszbtHnMHGxfPntz8gEqfKFjHrM1LSCkWxuiYx92Nj7EHFY5vnM7\n\n    const link = new URL(\n        `https://explorer.ergoplatform.com/payment-request?address=${address}&amount=${\n            amount / 1000000000\n        }`,\n    );\n\n    return (\n        <PaymentGateDiv>\n            <ObservableContentComponent\n                content={paymentStatus\n                    .pipe(\n                        map(({ checkedDate, isPayed }) =>\n                            !isPayed ? (\n                                <>\n                                    <QRCode {...{ link }} />\n                                    Pay {amount / 1000000000} ERG to address{' '}\n                                    <a\n                                        href={link.href}\n                                        target=\"_blank\"\n                                        rel=\"noopener noreferrer\"\n                                    >\n                                        {address}\n                                    </a>\n                                    <br />\n                                    In{' '}\n                                    <Countdown\n                                        date={dueDate}\n                                        overtime={false}\n                                        renderer={({ minutes, seconds }) => (\n                                            <>\n                                                {minutes}:{seconds}\n                                            </>\n                                        )}\n                                    />\n                                    <br />\n                                    until{' '}\n                                    {\n                                        dueDate.toUTCString() /* TODO: Some smarter component to show date and time - maybe use moment.js */\n                                    }\n                                    <hr />\n                                    <Loader /> Waiting for payment\n                                    <br />\n                                    Last checked at{' '}\n                                    {\n                                        checkedDate.toUTCString() /* TODO: Some smarter component to show date and time - maybe use moment.js */\n                                    }\n                                </>\n                            ) : (\n                                <>\n                                    Succesfully payed!\n                                    {/* TODO: !!! Place here a link or redirection */}\n                                </>\n                            ),\n                        ),\n                    )\n                    .pipe(\n                        catchError((error: Error) => of(<>{error.message}</>)),\n                    )}\n            />\n        </PaymentGateDiv>\n    );\n}\n\nconst PaymentGateDiv = styled.div`\n    font-size: 11px;\n    width: 500px;\n`;\n","import { jsPDF } from 'jspdf';\nimport React, { useRef } from 'react';\nimport styled from 'styled-components';\nimport { Promisable } from 'type-fest';\n//import html2canvas from 'html2canvas';\n\ninterface IPdfPageProps extends React.PropsWithChildren<{}> {\n    createUi: (options: {\n        createPdf: () => Promise<Blob>;\n    }) => Promisable<JSX.Element | JSX.Element[]>;\n}\n\nexport function PdfPage(props: IPdfPageProps) {\n    const pageRef = useRef(null);\n\n    return (\n        <div>\n            {props.createUi({\n                createPdf: async () => {\n                    const doc = new jsPDF();\n\n                    // TODO: !!! Through nice html2canvas\n\n                    //const canvas = await html2canvas(pageRef!.current!);\n                    //const image = canvas.toDataURL();\n\n                    // !!! document.body.appendChild(canvas);\n\n                    //doc.addImage(image, 'JPEG', 0, 0, 210, 297);\n                    //doc.html((pageRef!.current as any).innerHTML, { x: 10, y: 10 });\n\n                    //console.log(pageRef!.current as any);\n                    //console.log((pageRef!.current as any).innerText);\n                    //doc.html((pageRef!.current as any).innerHTML, { x: 10, y: 10 });\n                    doc.text((pageRef!.current as any).innerText, 10, 10);\n\n                    return doc.output('blob');\n                },\n            })}\n            <PdfPageDiv ref={pageRef}>{props.children}</PdfPageDiv>\n        </div>\n    );\n}\n\nconst PdfPageDiv = styled.div`\n    width: ${210 * 2}px;\n    height: ${297 * 2}px;\n    border: 2px solid #009edf;\n\n    background-color: white;\n    color: black;\n`;\n","import * as React from 'react';\nimport styled from 'styled-components';\n\nexport type IUploadZoneProps = React.PropsWithChildren<{\n    clickable?: boolean;\n    onFilesOver?: (isFileOver: boolean) => void;\n    onFiles: (droppedFiles: File[]) => void;\n}>;\n\n// TODO: !!! Use hooks and functional coponent ONLY in whole project\n\nexport class UploadZone extends React.Component<IUploadZoneProps> {\n    render() {\n        const {\n            children,\n            onFiles: onFile,\n            onFilesOver: onFileOver,\n            clickable,\n        } = this.props;\n        const onFileOverMaybe = (isFileOver: boolean) => {\n            if (onFileOver) {\n                onFileOver(isFileOver);\n            }\n        };\n\n        let uploadClick: () => void;\n\n        return (\n            <UploadZoneDiv\n                onClick={() => {\n                    if (clickable) {\n                        uploadClick();\n                    }\n                }}\n                onDragEnter={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }}\n                onDragOver={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                    onFileOverMaybe(true);\n                }}\n                onDragExit={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                    onFileOverMaybe(false);\n                }}\n                onDragEnd={(event) => {\n                    event.stopPropagation();\n                    event.preventDefault();\n                }}\n                onDrop={(event) => {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    onFileOverMaybe(false);\n\n                    const files = Array.from(event.dataTransfer.files); // TODO: Maybe there should be event.dataTransfer.items handler\n                    onFile(files);\n                }}\n            >\n                <input\n                    type=\"file\"\n                    ref={(element) => {\n                        if (element) {\n                            uploadClick = () => {\n                                onFileOverMaybe(true);\n                                (element as HTMLInputElement).click();\n                            };\n                        }\n                    }}\n                    onChange={(event) => {\n                        if (!event || !event.target || !event.target.files)\n                            return;\n                        onFile(Array.from(event.target.files));\n                    }}\n                />\n\n                {children}\n            </UploadZoneDiv>\n        );\n    }\n}\n\nconst UploadZoneDiv = styled.div`\n    width: ${210}px;\n    height: ${297}px;\n    padding: 10px;\n    border: 5px dashed #009edf;\n\n    input {\n        display: none;\n    }\n`;\n","export function readFile(file: File | Blob): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n\n        reader.addEventListener('loadend', (event) =>\n            resolve(event.target!.result as ArrayBuffer),\n        );\n        reader.addEventListener('error', reject);\n\n        reader.readAsArrayBuffer(file);\n    });\n}\n","import { readFile } from './readFile';\n\nexport async function getAsByteArray(file: File | Blob): Promise<Uint8Array> {\n    return new Uint8Array(await readFile(file));\n}\n","export function uint8ArrayToHex(uint8Array: Uint8Array) {\n    return [...uint8Array].map((x) => x.toString(16).padStart(2, '0')).join('');\n}\n","// @ts-ignore: no typings\nimport { blake2bFinal, blake2bInit, blake2bUpdate } from 'blakejs';\nimport { getAsByteArray } from '../utils/getAsByteArray';\nimport { uint8ArrayToHex } from '../utils/uint8ArrayToHex';\n\nexport async function blake2b256(input: File | Blob): Promise<string> {\n    const KEY = null; // optional key\n    const OUTPUT_LENGTH = 32; // bytes\n    const context = blake2bInit(OUTPUT_LENGTH, KEY || undefined);\n\n    // each time you get a byte array from the stream:\n    blake2bUpdate(context, await getAsByteArray(input));\n\n    // finally, once the stream has been exhausted\n    const hashUint8Array = blake2bFinal(context);\n    // returns a 64-byte hash, as a Uint8Array\n\n    const hash = uint8ArrayToHex(hashUint8Array);\n\n    return hash;\n}\n","import { IOracle } from './_IOracle';\n\nexport abstract class AbstractBlockcyptherOracle\n    implements IOracle<{ hash: string }>\n{\n    public abstract name: string;\n    public abstract title: string;\n\n    public dataTitles = { hash: 'Current block hash' };\n    public ttl = -1;\n\n    public async getData() {\n        const response = await fetch(\n            `https://api.blockcypher.com/v1/${this.name.toLowerCase()}/main` /*`https://blockchain.info/latestblock`*/,\n            /*{ mode: 'no-cors' }*/\n        );\n        // console.log({ response });\n        const body = await response.json();\n\n        if (body.error) {\n            throw new Error(body.error);\n        }\n\n        const { hash } = body;\n        return { hash };\n    }\n}\n","import { AbstractBlockcyptherOracle } from './_AbstractBlockcyptherOracle';\n\nexport class BitcoinOracle extends AbstractBlockcyptherOracle {\n    public name = 'BTC';\n    public title = 'Bitcoin';\n}\n","import { IOracle } from './_IOracle';\n\nexport class DateOracle implements IOracle<{ date: string; time: string }> {\n    public name = 'DATE';\n    public title = 'Current';\n    public ttl = 1;\n\n    public dataTitles = { date: 'date', time: 'time' };\n\n    public getData() {\n        const date = new Date(/* TODO: Taking user date can be dangerous, use some remote time. */);\n        return {\n            date: `${date.getUTCFullYear()}-${('0' + date.getUTCMonth()).slice(\n                -2,\n            )}-${('0' + date.getUTCDate()).slice(-2)}`,\n            time: `${('0' + date.getUTCHours()).slice(-2)}:${(\n                '0' + date.getUTCMinutes()\n            ).slice(-2)}:${('0' + date.getUTCSeconds()).slice(-2)}`,\n        };\n    }\n}\n","import { AbstractBlockcyptherOracle } from './_AbstractBlockcyptherOracle';\n\nexport class EthereumOracle extends AbstractBlockcyptherOracle {\n    public name = 'ETH';\n    public title = 'Ethereum';\n}\n","import { AbstractBlockcyptherOracle } from './_AbstractBlockcyptherOracle';\n\nexport class LitecoinOracle extends AbstractBlockcyptherOracle {\n    public name = 'LTC';\n    public title = 'Litecoin';\n}\n","import RssParser from 'rss-parser';\nimport { IOracle } from './_IOracle';\n\nexport class NytimesOracle implements IOracle<{ firstTitle: string }> {\n    public name = 'NYTIMES';\n    public title = 'The New York Times';\n    public ttl = -1;\n\n    public dataTitles = { firstTitle: 'first title' };\n\n    public async getData() {\n        const rssParser = new RssParser();\n        const feed = await rssParser.parseURL(\n            `https://rss.nytimes.com/services/xml/rss/nyt/World.xml`,\n        );\n\n        // console.log({ feed });\n\n        return {\n            firstTitle: feed.items[0].title as string,\n        };\n    }\n}\n","import { ergo_wallet_address } from '../interfaces/stringTypes';\nimport { Address } from \"@coinbarn/ergo-ts\";\n\nexport async function isUserAddressValid(\n    userAddress: ergo_wallet_address,\n): Promise<boolean> {\n    try {\n        return (new Address(userAddress).isValid())\n    } catch (_) {\n        return false;\n    }\n}\n\nexport async function isProxyContractAddressValid(\n    userAddress: ergo_wallet_address,\n): Promise<boolean> {\n    // TODO: !!! Implement, value is hardcoded\n    return true;\n}\n\n","import { ConfigChecker } from 'configchecker';\n///* tslint:disable:no-var-requires */\n//const packageJson = require('../package.json');\nimport { version } from '../package.json';\n\nexport const VERSION = version;\n\nconst config = ConfigChecker.from(process.env);\n\n// TODO @hejny - see comments bellow\n// TODO - add testnet/mainnet switch\n// TODO - add config for ergo explorer url and subdomains for testnet/mainnet variant\n\nexport const ERGO_ASSEMBLER_URL = config\n    .get(\n        'REACT_APP_ERGO_ASSEMBLER_URL' /* TODO: configchecker can ignore prefxes in ConfigChecker.from */,\n    )\n    .url()\n    // TODO: .checkHttps()\n    // TODO: .checkNativePort()\n    // TODO: universal .check() in configchecker\n    .required().value!;\n\nexport const BUILD_DETAILS_URL = config\n    .get(\n        'REACT_APP_BUILD_DETAILS_URL' /* TODO: configchecker can ignore prefxes in ConfigChecker.from */,\n    )\n    .url().value;\n\n/**\n * TODO: This is not working with GitHub actions.\n */\nexport const BUILD_DATE = config\n    .get(\n        'REACT_APP_BUILD_DATE' /* TODO: configchecker can ignore prefxes in ConfigChecker.from */,\n    )\n    .date().value;\n","import { ERGO_ASSEMBLER_URL } from '../config';\nimport {\n    ergo_scala_script,\n    ergo_script_address,\n} from '../interfaces/stringTypes';\n\n/**\n * Copiles source in scala to Ergo3 adress format\n * @param source in scala\n */\nexport async function compileErgoScript({\n    script,\n}: {\n    script: ergo_scala_script;\n}): Promise<{ address: ergo_script_address }> {\n    const body = JSON.stringify(script.trim())\n        // TODO: !!! Is this required\n        .split('^\\n')\n        .join('\\n')\n        .split('\\n\\n')\n        .join('\\n');\n\n    const url = `${ERGO_ASSEMBLER_URL.href}compile`;\n    const compilerResponse = await fetch(url, {\n        method: 'POST',\n        body,\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    }).catch(() => {\n        throw new Error(`Failed to fetch compile service on \"${url}\".`);\n    });\n\n    const compilerResponseBody = await compilerResponse.json();\n\n    if (compilerResponseBody.success === false) {\n        throw new Error(\n            `Failed to compile Ergo script:\\n${compilerResponseBody.detail}`,\n        );\n    }\n\n    return compilerResponseBody;\n}\n","import { ergo_scala_script, string_href } from '../interfaces/stringTypes';\n\nexport async function createScript<T extends { script: string_href }>(\n    options: T,\n): Promise<{ script: ergo_scala_script }> {\n    const response = await fetch(options.script);\n    let script = await response.text();\n\n    // console.log({ script });\n\n    for (const [key, value] of Object.entries(options).filter(\n        // tslint:disable-next-line:no-shadowed-variable\n        ([key]) => key !== 'script',\n    )) {\n        const scriptArray = script.split(`$${key}`);\n        if (scriptArray.length === 1) {\n            throw new Error(\n                `Could not find param \"${key}\" in the script \"${options.script}\"`,\n            );\n        }\n        script = scriptArray.join(value);\n    }\n\n    // TODO: Probbably extract function replaceParams\n\n    const match = script.match(/\\$[a-zA-Z0-9]+/g);\n    if (match) {\n        throw new Error(\n            `Missing params ${match\n                .map((param) => `\"${param.substring(1)}\"`)\n                .join(', ')} for the script \"${options.script}\".`,\n        );\n    }\n\n    return { script };\n}\n","export async function getCurrentBlockchainHeight(): Promise<number> {\n\n    const response = await fetch(\n        `https://api-testnet.ergoplatform.com/api/v1/info`,\n    );\n\n    const body = await response.json();\n\n    return body.height;\n}\n\n//TODO - probably return raw fee costs, so we can use them in different ways later on\nexport async function getCurrentBlockchainMinFeeRequired(): Promise<number> {\n\n    const response = await fetch(\n        `https://api-testnet.ergoplatform.com/api/v1/info`,\n    );\n\n    const body = await response.json();\n\n    const inputCost = body.params.inputCost;\n    const outputCost = body.params.outputCost;\n    const tokenAccessCost = body.params.tokenAccessCost;\n\n    //this should be true for token minting transaction using input from proxy smart contract address UTXO\n    return ((1 * inputCost) + (2 * outputCost) + (1 * tokenAccessCost));\n}\n","import { ergo_format, string_hex } from '../../../interfaces/stringTypes';\n\n/**\n *\n * @param hex string\n * @returns ergo format string used for example in R8\n */\nexport function hexToErgoFormat(hex: string_hex): ergo_format {\n    // TODO: !!! Unhardcode length of ergo format string\n    return `0e20${hex}`;\n}\n","import { ergo_format, string_url } from '../../../interfaces/stringTypes';\nimport { convertToHex } from '../../../utils/convertToHex';\n\n/**\n *\n * @param url string\n * @returns ergo format string used for example in R8\n */\nexport function urlToErgoFormat(url: string_url): ergo_format {\n    return `0e${url.length.toString(16)}${convertToHex(url)}`;\n}\n","import { string_hex } from \"../interfaces/stringTypes\";\n\nexport function convertToHex(str: string): string_hex {\n    let hex = '';\n    for (let i = 0; i < str.length; i++) {\n        hex += '' + str.charCodeAt(i).toString(16);\n    }\n    return hex;\n}\n","import { BehaviorSubject } from 'rxjs';\nimport { forTimeSynced } from 'waitasecond';\nimport { ERGO_ASSEMBLER_URL } from '../config';\nimport { IPaymentStatus } from '../interfaces/IPaymentStatus';\nimport {\n    ergo_script_address,\n    ergo_wallet_address,\n    nanoerg,\n    string_hex,\n} from '../interfaces/stringTypes';\nimport { hexToErgoFormat } from './ergoFormat/hex/hexToErgoFormat';\nimport { urlToErgoFormat } from './ergoFormat/url/urlToErgoFormat';\n\n/**\n * TODO: !!! Probbably rename to something like followPaymentRequest\n */\nexport async function sendFollowRequest({\n    compiledSmartContractAddress,\n    userAddress,\n    sigmaStampProviderAddress,\n    documentHashInHex,\n    ergsSendTogetherWithNFT,\n    ergsFeeForSigmaStampService,\n    mintingFee,\n}: {\n    compiledSmartContractAddress: ergo_script_address;\n    userAddress: ergo_wallet_address;\n    /**\n     * TODO: !!! Is it ergo_script_address OR ergo_wallet_address\n     */\n    sigmaStampProviderAddress: ergo_script_address;\n    documentHashInHex: string_hex;\n    ergsSendTogetherWithNFT: nanoerg;\n    ergsFeeForSigmaStampService: nanoerg;\n    mintingFee: nanoerg;\n}): Promise<{\n    amount: nanoerg;\n\n    /**\n     * TODO: is it really in seconds?!\n     * TODO: Make it absolute by Date\n     */\n    dueDate: Date;\n    paymentStatus: IPaymentStatus;\n}> {\n    const amount: nanoerg =\n        ergsSendTogetherWithNFT + ergsFeeForSigmaStampService + mintingFee;\n\n    const requestBody = {\n        address: compiledSmartContractAddress,\n        returnTo: userAddress,\n        startWhen: { erg: amount },\n        txSpec: {\n            requests: [\n                {\n                    ergValue: ergsSendTogetherWithNFT,\n                    address: userAddress,\n                    name: 'SigmaStampNFT',\n                    amount: 1,\n                    decimals: 0,\n                    description:\n                        'Proof of existence of document with Blake2b-256 hash specified in R8 register during minting of this NFT token.',\n                    registers: {\n                        R7: '0e0201de',\n                        R8: hexToErgoFormat(documentHashInHex),\n                        R9: urlToErgoFormat(\n                            // TODO: decide about address format + move it into config ???\n                            // @hejny @nitram147 - decide about URL path to use\n                            `http://sigmastamp.ml/#/verify?hash=${documentHashInHex}`,\n                        ),\n                    },\n                },\n                {\n                    value: ergsFeeForSigmaStampService,\n                    address: sigmaStampProviderAddress,\n                },\n            ],\n            fee: mintingFee,\n            inputs: ['$userIns'],\n            dataInputs: [],\n        },\n    };\n\n    const followResponse = await fetch(`${ERGO_ASSEMBLER_URL.href}follow`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(requestBody),\n    });\n\n    const followResponseBody = await followResponse.json();\n    const { id: transactionId, dueTime } = followResponseBody;\n\n    const dueDate = new Date(new Date().getTime() + dueTime * 1000);\n\n    // TODO: Probbably split creation of paymentStatus into new function\n    const paymentStatus = new BehaviorSubject({\n        checkedDate:\n            new Date(/* TODO: Taking user date can be dangerous, use some remote time. */),\n        isPayed: false,\n    }) as IPaymentStatus;\n\n    (async () => {\n        // TODO: Do this by a Destroyable Registration without [IIFE with side-effects]\n        while (true) {\n            await forTimeSynced(1000);\n\n            if (\n                new Date(/* TODO: Taking user date can be dangerous, use some remote time. */).getTime() >\n                dueDate.getTime()\n            ) {\n                paymentStatus.error(\n                    new Error(\n                        'Timeout' /* TODO: TimeoutError class + better message */,\n                    ),\n                );\n                paymentStatus.complete(/* TODO: Should be this there after error?! */);\n                return;\n            }\n\n            // Loop\n            const watchResponse = await fetch(\n                `${ERGO_ASSEMBLER_URL.href}result/${transactionId}`,\n            );\n            const watchResponseBody = await watchResponse.json();\n            const {\n                /*id, */tx,\n                detail /* \"pending\", \"returning\", \"mined\", \"success\", \"timeout\", \"return failed\" */,\n            } = watchResponseBody;\n\n            console.log({ watchResponse, watchResponseBody, tx, detail });\n\n            if (detail === 'success') {\n                // TODO: !!! And now take tx and create big certificate\n\n                paymentStatus.next({\n                    checkedDate:\n                        new Date(/* TODO: Taking user date can be dangerous, use some remote time. */),\n                    isPayed: true,\n                });\n                paymentStatus.complete();\n                return;\n            }\n\n            paymentStatus.next({\n                checkedDate:\n                    new Date(/* TODO: Taking user date can be dangerous, use some remote time. */),\n                isPayed: false,\n            });\n        }\n    })();\n\n    return {\n        amount,\n        dueDate,\n        paymentStatus,\n    };\n}\n\n/*\nTODO: Instructions from Martin how to fix a follow request\n\n\nR9 nema vyzera tak ako vyzera\nAni R8\n\n---\n\nMajme Blake2b-256 bitovy hash v HEX formate napriklad:\n4d1a7eb6b84817769808c9a8a15ac240470d21b3b6f20e93795c2e2c6bae92be\n\nR8 bude obsahovat TYP_DAT---DLZKU_DAT_V_HEX---DATA_V_HEX (pricom miesto --- tam nie je nic, len to ide za sebou)\nTyp dat je 0e\nDlzka dat je 20 [hexa] (kedze to je 20hex == 32 dec -> 32 * 8 (pretoze 1byte = 8bit) = 256 a nas hash je prave 256bitovy)\nNo a samotne data budu ten hash cize: 4d1a7eb6b84817769808c9a8a15ac240470d21b3b6f20e93795c2e2c6bae92be\n\nCize v R8 bude:\n\"R8\": \"0e204d1a7eb6b84817769808c9a8a15ac240470d21b3b6f20e93795c2e2c6bae92be\"\nKedze je dlzka hashu stabilna a aj typ dat tak to mozes zobrat jednoducho tak ze pred hex prezentaciu hashu tj napr \"4d1a7eb6b84817769808c9a8a15ac240470d21b3b6f20e93795c2e2c6bae92be\" vlozis \"0e20\"\nCize to tam hardcodnes\n\n----\n\nR9 bude obsahovat rovnakym sposobom encodovane data v ktorych bude URL\nCize 0e na zaciatok ako typ\nPotom XY kde XY je hexa hodnota urcuju kolko bytov dat bude nasledovat\nA nasledne ascii znaky url prevedene na hexa\nNa to som si vtedy pre seba napisal jednoduchy skript s nazvom \"string_to_ergobytes.py\"\n\n```\n#!/usr/bin/env python3\n\nimport sys\nimport base58\nimport hashlib\n\ndef print_usage(binary_name):\n\tprint(\"python ./\" + binary_name + \" todo\")\n\tprint(\"\\tWhere todo\")\n\nif len(sys.argv) != 2:\n\tprint_usage(sys.argv[0])\n\tsys.exit(1)\n\ninput = sys.argv[1]\n\n\ninput_len = len(input)\n\nresult = \"0e\" + '{:02x}'.format(input_len) + input.encode(\"utf-8\").hex()\n\nprint(result)\n\nsys.exit(0)\n```\n\n\ntie includes na base58 a aj hashlib mozes vyhodit, tie mi tam ostali z ineho ergopython toolu, ktory som vyrabal...\n\na spustis to len ako\n\npython ./string_to_ergobytes.py \"https://www.sigmastamp.ml/verify/blabla...\"\n\nTym si odskusat ako ma ta url vyzerat encodovana aby si mohol napisal JS ekvivalent toho\n\nPotom by to uz vsetko malo ist :)\n\n*/\n","import { IPaymentStatus } from '../interfaces/IPaymentStatus';\nimport {\n    ergo_script_address,\n    ergo_wallet_address,\n    nanoerg\n} from '../interfaces/stringTypes';\nimport { isUserAddressValid } from './addressValidator';\nimport { compileErgoScript } from './compileErgoScript';\nimport { createScript } from './createScript';\nimport { getCurrentBlockchainHeight } from './getCurrentBlockchainInfo';\nimport { sendFollowRequest } from './sendFollowRequest';\n\ninterface ICreateSigmaStampNFT {\n    documentHashInBase64: string;\n    documentHashInHex: string;\n    userAddress: ergo_wallet_address;\n}\n\nexport async function createSigmaStampNFT({\n    userAddress,\n    documentHashInBase64,\n    documentHashInHex,\n}: ICreateSigmaStampNFT): Promise<{\n    amount: nanoerg;\n    address: ergo_script_address;\n    dueDate: Date;\n    paymentStatus: IPaymentStatus;\n}> {\n    if (!(await isUserAddressValid(userAddress))) {\n        throw new Error(`User address \"${userAddress}\" is not correct.`);\n    }\n\n    //TODO @nitram147 @hejny validate whether hash already exists in blockchain (same way as in the verification phase)\n    //if hash exists there, show user warning that this file was already stamped via sigmastamp and cannot be done more times\n    //[of couse somebody can stamp this file again on its own, however will we be taking into account only the first occurence of this hash in blockchain - so the guy who stamped it first is the original owner of the file]\n\n\n    //TODO use getCurrentBlockchainMinFeeRequired to get current min fee\n    //allow user to set multiples of this value to increase/decrease minting priority\n    //TODO @hejny - design custom form in which user will setup:\n    // 1.) user's address\n    // 2.) how fast he want to have his NFT to be minted (in multiples of minimum fee - see comment above)\n    // 3.) user could show hidden advanced setting which will include:\n    //     a.) setup of custom amount of ERG to send together with NFT token (so user will be able to transfer NFT in future ERG amount sent together with NFT will be used to cover transaction fees on ergo network)\n    //         there should be also tooltip (like question mark icon) which will include explanation text (which will explain what this ERG amount mean...)\n    //TODO @hejny @nitram147 - think about stamping service fee... (whether to make it stable or based on current erg price etc.)\n    const mintingFee = 20000000; /* TODO: User settable */\n    const ergsSendTogetherWithNFT = 100000000; /* TODO: User settable */\n    const ergsFeeForSigmaStampService = 100000000; /* Our fee */\n    //TODO @hejny - move harcoded values into some config file\n    const sigmaStampProviderAddress =\n        '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV';\n    const assetTypeValue = 'Ad4=';\n    //TODO @nitram147 - redesign this fee also to use getCurrentBlockchainMinFeeRequired function...\n    const returnTransactionFee = 10000000;\n\n    /**\n     * TODO: !!! unhardcode address\n     */\n    // TODO @hejny - move it also to some configuration...\n    const sigmaStampAssemblerNodeAddr =\n        '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV';\n    // TODO @hejny - same - move the value of \"10\" bellow to the config file\n    const refundHeightThreshold = (await getCurrentBlockchainHeight()) + 10;\n\n    console.log(\n        JSON.stringify({\n            ergsSendTogetherWithNFT,\n            userAddress,\n            ergsFeeForSigmaStampService,\n            sigmaStampProviderAddress,\n            assetTypeValue,\n            documentHashInBase64,\n            returnTransactionFee,\n            sigmaStampAssemblerNodeAddr,\n            refundHeightThreshold,\n        }),\n    );\n\n    const { script } = await createScript({\n        script: '/scripts/sigmastamp-nft.scala',\n\n        // TODO: Better names for variabiles below (replace everywhere in scala script + here):\n        ergsSendTogetherWithNFT,\n        userAddress,\n        ergsFeeForSigmaStampService,\n        sigmaStampProviderAddress,\n        assetTypeValue,\n        documentHashInBase64,\n        returnTransactionFee,\n        sigmaStampAssemblerNodeAddr,\n        refundHeightThreshold,\n    });\n\n    const { address: compiledSmartContractAddress } = await compileErgoScript({\n        script,\n    });\n\n    const { amount, dueDate, paymentStatus } = await sendFollowRequest({\n        compiledSmartContractAddress,\n        userAddress,\n        sigmaStampProviderAddress,\n        documentHashInHex,\n        ergsSendTogetherWithNFT,\n        ergsFeeForSigmaStampService,\n        mintingFee,\n    });\n\n    return {\n        amount,\n        address: compiledSmartContractAddress,\n        dueDate,\n        paymentStatus,\n    };\n}\n","import { saveAs } from 'file-saver';\nimport JSZip from 'jszip';\nimport React, { useState } from 'react';\nimport { Link } from 'react-router-dom';\nimport styled from 'styled-components';\nimport { AsyncContentComponent } from './components/AsyncContentComponent';\nimport { IPaymentGateProps, PaymentGate } from './components/PaymentGate';\nimport { PdfPage } from './components/PdfPage';\nimport { UploadZone } from './components/UploadZone';\nimport { blake2b256 } from './hash/blake2b256';\nimport { string_base64, string_hex } from './interfaces/stringTypes';\nimport { BitcoinOracle } from './oracles/BitcoinOracle';\nimport { DateOracle } from './oracles/DateOracle';\nimport { EthereumOracle } from './oracles/EthereumOracle';\nimport { LitecoinOracle } from './oracles/LitecoinOracle';\nimport { NytimesOracle } from './oracles/NytimesOracle';\nimport { createSigmaStampNFT } from './smartcontracts/createSigmaStampNFT';\nimport { hexToBase64 } from './utils/hexToBase64';\n\nconst ORACLES = [\n    new BitcoinOracle(),\n    new EthereumOracle(),\n    new LitecoinOracle(),\n    new DateOracle(),\n    new NytimesOracle(),\n];\n\ninterface IAppState {\n    files: File[];\n}\n\nexport function App() {\n    const [state, setState] = useState<IAppState>({ files: [] });\n    const [payment, setPayment] = useState<null | IPaymentGateProps>(null);\n\n    if (!payment) {\n        return (\n            <AppDiv>\n                {/*\n        <button\n          onClick={() => { console.log('test'); createCertificate() }}\n        >\n          Create document\n        </button>\n            <h1>Sigmastamp</h1>*/}\n\n                {state.files.length === 0 ? (\n                    <UploadZone\n                        onFiles={async (files) => {\n                            setState({ files });\n                            /*\n                    const file = files[0];\n\n                    const hash = await blake2b256(file);\n\n                    console.log({ files, file, hash });\n\n                    const certificateFile = createCertificate({ certificateFilename: 'certificate.pdf', hash });\n\n                    const zip = new JSZip();\n                    zip.file(file.name, file);\n                    zip.file(certificateFile.name, certificateFile);\n\n                    const zipFile = await zip.generateAsync({ type: 'blob' });\n                    saveAs(zipFile, 'certificate.zip');\n                    */\n                        }}\n                        clickable\n                    >\n                        Upload your file(s) here!\n                    </UploadZone>\n                ) : (\n                    <PdfPage\n                        createUi={({ createPdf }) => {\n                            return (\n                                <button\n                                    onClick={async () => {\n                                        const certificateFile = new File(\n                                            [await createPdf()],\n                                            'certificate1.pdf' /* TODO: Maybe add current {lastModified: 1534584790000}*/,\n                                        );\n\n                                        //saveAs(certificateFile);\n\n                                        const zip = new JSZip();\n                                        for (const file of state.files) {\n                                            zip.file(file.name, file);\n                                        }\n                                        zip.file(\n                                            certificateFile.name,\n                                            certificateFile,\n                                        );\n\n                                        const zipBlob = await zip.generateAsync(\n                                            { type: 'blob' },\n                                        );\n\n                                        const zipHash: string_hex =\n                                            await blake2b256(zipBlob);\n\n                                        const zipHashBase64: string_base64 =\n                                            await hexToBase64(zipHash);\n\n                                        saveAs(\n                                            zipBlob,\n                                            `certificate1.${zipHash.substring(\n                                                0,\n                                                5,\n                                            )}.zip`,\n                                        );\n\n                                        // TODO: !!! Nicer user input than prompt\n                                        // TODO @hejny - replace this with custom form (details mentioned in createSigmaStampNFT.ts)\n                                        // TODO @hejny - also move proof of today function away, so user will be able to decide whether he want to stamp file or he will make special version of file via proof of today page and then he will stamp this proof of today generated zip file (certificate)\n                                        // but it should be always opt-in, not opt-out !!!\n                                        const userAddress = prompt(\n                                            'Please fill your Ergo address',\n                                            '3Ww7y6vi4NhFZ1ufsEF8vQNyGrvhNmeMmDWP9h3s4qSEFSMoGooV' /* !!! Unhardocde */,\n                                        );\n                                        if (!userAddress) {\n                                            return;\n                                        }\n\n                                        //TODO @hejny - include also page for \"return\" - this page will be used in case that ergo-assembler failed and users funds got stucked on proxy-smartcontract, see https://sigmausd.io/#/refund <-- we need to implement something like this or the exact \"clone\" of this...\n\n                                        setPayment(\n                                            await createSigmaStampNFT({\n                                                userAddress,\n                                                documentHashInBase64:\n                                                    zipHashBase64,\n                                                documentHashInHex: zipHash,\n                                            }),\n                                        );\n                                    }}\n                                >\n                                    Download 1st certificate\n                                </button>\n                            );\n                        }}\n                    >\n                        {state.files.map((file) => (\n                            <AsyncContentComponent\n                                key={file.name}\n                                content={async () => {\n                                    const hash = await blake2b256(file);\n                                    return (\n                                        <>\n                                            <b>Hash of {file.name}</b> is {hash}\n                                        </>\n                                    );\n                                }}\n                            />\n                        ))}\n\n                        {ORACLES.map((oracle) => (\n                            <div key={oracle.name}>\n                                <AsyncContentComponent\n                                    content={async () => {\n                                        const data = await oracle.getData();\n\n                                        return (\n                                            <>\n                                                {Object.entries(data).map(\n                                                    ([key, value]) => (\n                                                        <div key={key}>\n                                                            <b>\n                                                                {/* @ts-ignore: Object.entries is dummy and cannot pass propper index signature type */}\n                                                                {oracle.title}\n                                                                {\n                                                                    (\n                                                                        oracle as any\n                                                                    )\n                                                                        .dataTitles[\n                                                                        key\n                                                                    ]\n                                                                }\n                                                                :\n                                                            </b>\n                                                            {value}\n                                                        </div>\n                                                    ),\n                                                )}\n                                            </>\n                                        );\n                                    }}\n                                />\n                            </div>\n                        ))}\n                    </PdfPage>\n                )}\n\n                <ul>\n                    <li>\n                        <Link to=\"/verify\" target={'_blank'}>\n                            Or verify your 1st certificate.\n                        </Link>\n                    </li>\n                    <li>\n                        <Link to=\"/about\">\n                            TODO: !!! Short information about Sigmastamp,\n                            version and the build (leading to the more detailed\n                            information)\n                        </Link>\n                    </li>\n                </ul>\n            </AppDiv>\n        );\n    } else {\n        return <PaymentGate {...payment} />;\n    }\n}\n\nconst AppDiv = styled.div`\n    a {\n        color: #555;\n        font-size: 0.7em;\n    }\n`;\n","import { string_base64, string_hex } from '../interfaces/stringTypes';\n\nexport function hexToBase64(str: string_hex): string_base64 {\n    return btoa(\n        String.fromCharCode.apply(\n            null,\n            // @ts-ignore:\n            str\n                .replace(/\\r|\\n/g, '')\n                .replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ')\n                .replace(/ +$/, '')\n                .split(' '),\n        ),\n    );\n}\n","import { blake2b256 } from '../hash/blake2b256';\n\n//TODO rename function below\nexport async function validateFirstCertificate(firstCertificate: File) {\n\n    const hash = await blake2b256(firstCertificate);\n\n    const tokensResponse = await fetch(\n        `https://api-testnet.ergoplatform.com/api/v1/tokens/search?query=SigmaStampNFT`,\n    );\n    const tokensBody = await tokensResponse.json();\n\n    for(const item of tokensBody.items){\n\n        //skip non-NFTs\n        if(item.emissionAmount !== 1) continue;\n\n        const boxId = item.boxId;\n\n        const boxesResponse = await fetch(\n            `https://api-testnet.ergoplatform.com/api/v1/boxes/${boxId}`,\n        );\n\n        const boxesBody = await boxesResponse.json();\n\n        //skip non-SigmaStampNFT types\n        //(0x01 specifies NFT category, 0xde specifies SigmaStampNFT subcategory)\n        //see (https://github.com/ergoplatform/eips/blob/master/eip-0004.md) for more info\n        if(boxesBody.additionalRegisters.R7.renderedValue !== `01de`) continue;\n\n        if(boxesBody.additionalRegisters.R8.renderedValue === `${hash}`){\n            return boxesBody;\n        }\n    }\n\n    return null;\n}\n\n//TODO @nitram147 - function to check whether is hash already in blockchain\n//it would be similar to validateFirstCertificate function\n//maybe it would be great to extract the core functionality into one function and then only make wrapper for it (so validateFirstCertificate will be only a wrapper)\n\nexport async function getTransactionTime(txId: string) {\n\n    const response = await fetch(\n        `https://api-testnet.ergoplatform.com/api/v1/transactions/${txId}`,\n    );\n    const body = await response.json();\n\n    console.log('getTransactionTime', body);\n\n    const timestamp = body.timestamp;\n    const tokenId = body.outputs[0].assets[0].tokenId;\n\n    return { timestamp, tokenId };\n}\n\nexport async function getNFTHolderAddress(tokenId: string) {\n\n    const response = await fetch(\n        `https://api-testnet.ergoplatform.com/api/v1/boxes/unspent/byTokenId/${tokenId}`,\n    );\n    const body = await response.json();\n\n    console.log('getNFTHolderAddress', body);\n\n    //check that there is only one holder (it means that it is NFT and also that it exists)\n    if(body.total !== 1) return null;\n\n    return body.items[0].address;\n}\n","import JSZip from 'jszip';\nimport React, { useState } from 'react';\nimport { Link } from 'react-router-dom';\nimport styled from 'styled-components';\nimport { PdfPage } from './components/PdfPage';\nimport { UploadZone } from './components/UploadZone';\nimport { blake2b256 } from './hash/blake2b256';\nimport {\n    getNFTHolderAddress,\n    getTransactionTime,\n    validateFirstCertificate,\n} from './smartcontracts/validateFirstCertificate';\nimport { saveAs } from 'file-saver';\n\nexport function VerifyApp() {\n    const [files, setFiles] = useState<any>([]);\n    const [verification, setVerification] = useState<any>(null);\n\n    if (!verification) {\n        return (\n            <VerifyAppDiv>\n                <UploadZone\n                    onFiles={async (droppedFiles) => {\n                        const firstCertificate = droppedFiles[0];\n                        setFiles([droppedFiles[0]]);\n\n                        const droppedFileVerification = await validateFirstCertificate(\n                            firstCertificate,\n                        );\n\n                        if (!droppedFileVerification) {\n                            alert(\n                                `Your 1st certificate is still not validated through Ergo blockchain.`,\n                            );\n                            // TODO @hejny - see comments bellow\n                            // TODO - consider skipping the rest because extraction of transactionId from null in\n                            // the following statements will result in error\n                        }\n\n                        const { transactionId } = droppedFileVerification;\n\n                        const { timestamp, tokenId } = await getTransactionTime(\n                            transactionId,\n                        );\n                        //TODO @hejny @nitram147 - handle null in case that there isn't asset holder\n                        //this could happen when somebody burned NFT token\n                        //(we know that the corresponding NFT has already existed based on validateFirstCertificate function)\n                        //(but we don't know whether it still exists...)\n                        const currentHolder = await getNFTHolderAddress(tokenId);\n\n                        setVerification({\n                            ...droppedFileVerification,\n                            timestamp,\n                            tokenId,\n                            currentHolder,\n                        });\n                        console.log(droppedFileVerification);\n                    }}\n                    clickable\n                >\n                    Upload your 1st certificate.\n                </UploadZone>\n                <Link to=\"/\" target={'_blank'}>\n                    Or create your 1st certificate.\n                </Link>\n            </VerifyAppDiv>\n        );\n    } else {\n        return (\n            <PdfPage\n                createUi={({ createPdf }) => {\n                    return (\n                        <button\n                            onClick={async () => {\n                                const certificateFile = new File(\n                                    [await createPdf()],\n                                    'certificate2.pdf' /* TODO: Maybe add current {lastModified: 1534584790000}*/,\n                                );\n\n                                //saveAs(certificateFile);\n\n                                //TODO @hejny @nitram147 - design output format of verify PDF\n                                // also show somehow to user what amount of GPUs will be required to remine the chain to make\n                                // false proofs - this will be based on the block difficulty since the NFT mining block up to today\n                                // TODO @nitram147 - ask on discord whether there's some function on full node to find this difficulty value...\n                                const zip = new JSZip();\n                                for (const file of files) {\n                                    zip.file(file.name, file);\n                                }\n                                zip.file(certificateFile.name, certificateFile);\n\n                                const zipBlob = await zip.generateAsync({\n                                    type: 'blob',\n                                });\n\n                                const zipHash = await blake2b256(zipBlob);\n                                saveAs(\n                                    zipBlob,\n                                    `certificate2.${zipHash.substring(\n                                        0,\n                                        5,\n                                    )}.zip`,\n                                );\n                            }}\n                        >\n                            Download 2nd certificate\n                        </button>\n                    );\n                }}\n            >\n                <b>transactionId:</b> {verification.transactionId}\n                <br />\n                <b>timestamp:</b> {verification.timestamp}\n                <br />\n                <b>tokenId:</b> {verification.tokenId}\n                <br />\n                <b>current holder:</b> {verification.currentHolder}\n            </PdfPage>\n        );\n    }\n}\n\nconst VerifyAppDiv = styled.div`\n    a {\n        color: #555;\n        font-size: 0.7em;\n    }\n`;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { HashRouter, Route, Routes } from 'react-router-dom';\nimport styled from 'styled-components';\nimport { App } from './App';\nimport { BUILD_DATE, BUILD_DETAILS_URL, VERSION } from './config';\nimport './index.css';\nimport { VerifyApp } from './VerifyApp';\n\nconsole.info(\n    `%c Sigmastamp version ${VERSION}` +\n        (!BUILD_DATE ? `` : ` build at ${BUILD_DATE.toISOString()}`) +\n        (!BUILD_DETAILS_URL\n            ? ``\n            : ` view build details ${BUILD_DETAILS_URL.href}`),\n    `background: #009EDD; color: white; font-size: 1.1em; font-weight: bold; padding: 5px; border-radius: 3px;`,\n);\n\nconst HeaderElement = styled.header`\n    h1 {\n        font-size: 1em;\n    }\n`;\n\nReactDOM.render(\n    <React.StrictMode>\n        <HeaderElement>\n            <div id=\"sigmastamp_heading_div\">\n                <img\n                    className=\"logo_img\"\n                    alt=\"sigmastamp logo\"\n                    src=\"sigmastamp_logo.svg\"\n                />\n                <h1>SigmaStamp</h1>\n            </div>\n        </HeaderElement>\n\n        <HashRouter>\n            <Routes>\n                <Route path=\"/\" element={<App />} />\n                <Route path=\"/verify\" element={<VerifyApp />} />\n            </Routes>\n        </HashRouter>\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n"],"sourceRoot":""}